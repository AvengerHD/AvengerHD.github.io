---
layout: default
title: Effective Java 最佳实践
permalink: /pages/effective-java
---
## 实践原则
```
1) 用静态工厂方法代替构造器
   优点 
   <1>. 工厂方法名称更明确地描述产生的对象
   <2>. 不必每次都新建对象(单例模式)
   <3>. 可以返回原返回类型的任何子类型对象
   <4>. 在创建泛型类型实例的时候，简化代码
   缺点
   <1>. 如果没有 public 或 protected 的构造器，无法被继承
   <2>. 不容易与其他静态方法区分开

2) 如果有多个构造器参数，使用 Builder 模式
   优点:
   <1>. 代码编写容易，灵活度高
   缺点:
   <2>. 需要先创建 Builder 对象，性能低

3) 使用私有构造器或者枚举类型强化 Singleton 
   优点
   <1>. 保证全局唯一
   <2>. 更加灵活，不需改变 API 就可以改变是否是 Singleton
   <3>. 使用枚举的话，自动提供序列化机制，防止多次实例化，避免反射攻击，是最佳方法

4) 通过私有构造函数强化不可实例化的能力
   优点
   <1>. 避免工具类被实例化
   缺点
   <1>. 不能被继承

5) 避免创建不必要的对象
   eg: String a = new String("a") //Don't do this
   优先使用静态工厂方法实例化，而不是构造器
   优先使用基本数据类型而不是装箱基本类型
   慎重使用对象池

6) 消除过期对象引用
   自己管理内存时，如果释放元素，应当手动清除引用(比如置成 null)
   内存泄漏来源
   <1>. 过期引用未清除
   <2>. 缓存
   <3>. 监听器和回调

7) 避免使用 finalize 方法

8) 覆盖 equals 方法请遵守通用约定
   自反性：对象必须等于自身
   对称性：a.equals(b), b.equals(a)
   传递性：a.equals(b), b.equals(c), c.equals(a)
   一致性：如果两个对象相等，必须永远相等，除非某个对象被修改
   非空性：所有对象不等于 null

9) 覆盖 equals 时总要覆盖 hashCode
   equals 相等，hashCode 相等
   equals 不相等, hashCode 要尽量不同
     计算方法： result = 31 * result + c 通过上述公式将所有关键对象域散列码叠加

10) 建议覆盖 toString

11) 谨慎覆盖 clone
      clone 就是一个构造器，需要确保不会修改原始的对象
      克隆复杂对象：先调用 super.clone, 清空所有域，然后调用高层方法重新产生对象状态
      建议使用拷贝构造器或者拷贝工厂替代

12) 考虑实现 Comparable 接口
      compareTo 
      小于 -- 负整数，等于 -- 0，大于 -- 正整数

13) 使类和成员的可访问性最小
      减少模块耦合

14) 在公有类中使用访问方法而非公有域
      getter/setter

15) 使可变性最小化
      不可变对象 ：线程安全，可以自由共享
      <1>. 没有改变对象属性方法
      <2>. final 类
      <3>. 所有域都是 private + final 
      <4>. 如果类指向可变对象域，则该类的客户端无法获得这些引用

16) 复合优先于继承
   继承打破了封装性

17) 要么为继承而设计，并提供文档说明，要么就禁止继承

18) 接口优于抽象类
    抽象类只能单继承

19) 接口只用于定义类型
    不应该用来导出常量

20) 类层次优于标签类
    标签类指的是包含标签域的类

21) 用函数对象表示策略
    函数接口，策略模式

22) 优先考虑静态成员类
    避免和外围类实例关联，浪费空间时间

23) 不要再新代码中使用原生类型
    List a = ... //no generic type check
    List<String> a = .... //ok

24) 消除非受检警告
    不要使用 @SuppressWranings("unchecked") 隐藏警告

25) 列表优先于数组
    原因
    <1>. 数组是协变的，即如果 A extends B, A[] extends B[]
         泛型是不可变的，List<A> 和 List<B> 没有关系
         便于编译器报错
    <2>. 数组运行时才检查类型，泛型是可擦除的
    无法创建泛型数组：不是类型安全

26) 优先考虑泛型
    而不是使用类似 Object

27) 优先考虑泛型方法
    利用类型推导，是创建参数化类型实例更加容易

28) 利用有限通配符来提升 API 灵活性
    不要用通配符类型作为返回类型

29) 优先考虑类型安全的异构容器
    用Class对象作为键，类型令牌

30) 用 enum 代替 int 常量
    编译时类型安全

31) 枚举中用实例域代替序数
    enum {a(1), b(2)}

32) 用 EnumSet 代替位域
    从单个枚举类型中提取的多个值的集合

33) 用 EnumMap 代替序数索引
    最好不要用序数来索引数组，而要使用 EnumMap

34) 用接口模拟可伸缩的枚举
    枚举不可扩展，但是可以让枚举实现接口进行扩展

35) 注解优先于命名模式
    not testXXX, use @Test

36) 坚持使用 Override 注解

37) 用标记接口定义类型 
    标记接口 ： 不包含方法的空接口
       如果要定义任何新方法都不会关联的类型，选择标记接口
       如果要标记程序元素而不是类和接口，选择标记注解

38) 方法检查参数有效性
      尽早发现错误
      <1>. 不合法抛出异常
      <2>. assert 

39) 方法必要时保护性拷贝
      保护性拷贝是在检查参数有效性之前进行的，有效性检查是针对拷贝后的对象
      非不可变对象参数，不要使用 clone 方法进行保护性拷贝     

40) 谨慎设计方法签名
      便于理解，风格一致，方法不要太多，每个方法应当功能齐全，可以复用，参数列表不要太长(<=4)

41) 慎用重载
      不要导出两个具有相同参数数目的重载方法  

42) 慎用可变参数    
      没有传递任何参数时需要考虑边界条件
      每次调用都有数组分配和初始化，性能低

43) 方法应该返回空数组或集合，不是 null
      
44) 为所有导出的 API 元素编写文档注释

45) 局部变量作用域最小化
      在第一次使用的地方声明，声明时包含初始化表达式
      如果在循环终止后不再使用循环变量，for 循环优于 while 循环

46) for-each 循环优先于传统循环
      代码更简洁，性能基本不变
      无法使用 for-each 的场景
      <1>. 遍历集合，删除指定元素，需要使用显式的迭代器 remove
      <2>. 便利列表或数组，替换元素，需要使用列表迭代器或者数组索引
      <3>. 并行迭代多个集合

47) 了解和使用类库
      不要重复造轮子

48) 如果需要精确的答案，不要使用 float 和 double
      BigDecimal

49) 基本类型优先于装箱类型
      装箱类型更大更慢
      存在 null 可能
      == equals

50) 如果其他类型适合，避免使用字符串
      容易出错，更缓慢

51) 当心字符串连接的性能
      StringBuilder

52) 一般通过接口引用对象
      List<T> list = ....

53) 接口优先于反射机制
      反射没有类型检查，代码冗长复杂，性能低下

54) 谨慎地使用本地方法
      本地语言不安全，不可移植，难于调试

55) 谨慎地进行优化
      不要为了性能牺牲合理的结构
      优化前后，性能测试

56) 遵守普遍接受的命名惯例
      
57) 只针对异常的情况才使用异常
      异常不应该用于正常的控制流

58) 对可恢复的情况使用受检异常，对编程错误使用运行时异常

59) 避免不必要地使用受检的异常
      
60) 优先使用标准的异常

61) 抛出与抽象相对应的异常
      高层级封装低层级异常，抛出高层级异常，异常链

62) 每个方法抛出的异常都要有文档

63) 在细节信息中包含能捕获失败的信息
      异常的细节信息应该包含所有对"该异常有贡献"的参数和域的值

64) 努力使失败保持原子性
      失败的方法调用应该使对象保持在被调用之前的状态
      <1>. 执行操作前检查参数有效性
      <2>. 使得任何可能会失败的部分在对象状态修改之前
      <3>. 捕获失败，代码回滚或恢复，基于磁盘数据
      <4>. 对象临时拷贝上操作，成功后替换当前对象

65) 不要忽略异常

66) 同步访问共享的可变数据
      synchronized
      volatile

67) 避免过度同步
      性能降低，甚至死锁
      不要在同步区域内调用外来方法      

68) executor 和 task 优先于线程

69) 并发工具优先于 wait 和 notify
      即使使用 wait 和 notify：     
      从 while 循环内部调用 wait
      优先使用 notifyAll

70) 线程安全性的文档化

71) 慎用延迟初始化
      如果出于性能考虑而需要对静态域使用延迟初始化，请使用 lazy initialization holder class 模式
      private static class FieldHolder{
          static final Field field = xxx;
      }
      static Field getField() {return FieldHolder.field;}
      如果出于性能考虑需要对实例域使用延迟初始化，请使用双重检查模式
      private volatile Field field;
      Field getField(){
          Field result = field;
          if (result == null){
              synchronized(this){
                  result = field;
                  if (result == null){
                      field = result = xxx;
                  }
              }
          }
          return result;
      }

72) 不要依赖于线程调度器
      确保可运行线程平均数量不明显多于处理器的数量

73) 避免使用线程组

74) 谨慎地实现 Serializable 接口
      缺点
      <1>. 一旦类被公布，改变这个类的实现的灵活性大大降低
      <2>. 增加 Bug 和 安全漏洞的可能性
      <3>. 发行新版本增加测试负担

75) 考虑使用自定义的序列化形式

76) 保护性地编写 readObject 方法

77) 对于实例控制，枚举类型优先于readResolve

78) 考虑用序列化代理代替序列化实例
```